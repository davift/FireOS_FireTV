#include <stdio.h>
#include <amzn_secure_boot.h>
#include <amzn_unlock.h>
#include <amzn_secure_flashing.h>
#include <drvGPIO.h>
#include <drvSYS.h>
#include <common.h>

#if defined(UFBL_FEATURE_ONETIME_UNLOCK)
#include <amzn_onetime_unlock.h>
#include "onetime_unlock_key.h"
#endif

const char *amzn_target_device_name(void)
{
#if defined(CONFIG_MTK_BD_MT164B_10AT_M7632_DUCKIE)
  return "duckie";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_BRANDENBURG)
  return "brandenburg";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_SKIPPER)
  return "skipper";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_ANNA)
  return "anna";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_TEDDY)
  return "teddy";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_HAILEY)
  return "hailey";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_JULIANA)
  return "juliana";
#elif defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC)
  return "ABC";
#elif defined(CONFIG_MTK_BD_MT164B_10AT_M7632_SHELLY)
  return "shelly";
#elif defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC)
  return "ABC";
#endif
}

#define DEVICE_TYPE_GPIO PAD_PCM_A4

int gpio_is_production()
{

  return (!mdrv_gpio_get_level(DEVICE_TYPE_GPIO));
}

int amzn_target_device_type(void)
{
  if (anti_rb_enabled())
  {
    return AMZN_PRODUCTION_DEVICE;
  }
  else
    return AMZN_ENGINEERING_DEVICE;
}

int amzn_get_unlock_code(unsigned char *code, unsigned int *len)
{
  MS_U16 efuse_id[8];

  if (!code || !len || *len < (16 + 1))
    return -1;

  if (!MDrv_SYS_Init())
  {
    printf("MDrv_SYS_Init fail\n");
    return -1;
  }

  if (!MDrv_SYS_GetEfuseDid(efuse_id)) // 64 bits, but real value is 48 bits
  {
    printf("MDrv_SYS_GetEfuseDid fail\n");
    return -1;
  }

  *len = sprintf(code, "%04x%04x%04x%04x",efuse_id[3], efuse_id[2], efuse_id[1], efuse_id[0]);
  // printf("EFUSE ID %16s, len %d\n", code, *len);

  return 0;
}

const unsigned char *amzn_get_unlock_key(unsigned int *key_len)
{
#if defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC)
  static const unsigned char unlock_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xa7\x21\x60\x10\x38\x35\x61\x98\xc1\xed\xb5\x60\xa6\xac\xb2"
    "\x89\x2c\x6b\xa5\xd4\xe0\x36\xc3\xaf\x06\x4b\x5e\x50\xfe\xe6\x76"
    "\xd4\x0d\x69\x3d\xc5\x8b\x27\x6e\xf5\xf7\xed\xa4\xa2\xa5\x03\x30"
    "\x9b\xbe\xd6\x9d\x74\x27\x38\x25\xc4\x44\xe8\xf1\xd9\xd8\xc0\xa8"
    "\xdf\xb7\x3a\xe6\xab\x76\x9b\x00\x17\xe4\x1f\x5e\xe8\xc0\x25\x98"
    "\x00\xc7\x04\x5f\xf8\x85\xee\x9e\xe0\x26\xe0\xb6\x4f\x07\x55\xfb"
    "\x14\x9d\xba\x5a\x55\x80\x69\x89\x9f\x73\xd3\x98\x7f\x61\x44\x2c"
    "\x29\xd3\xf9\xf3\xd6\x16\x19\xcf\x80\xc3\x62\xa8\xa7\x78\xd8\x42"
    "\x78\xbe\x73\x39\x91\x52\x8b\x83\x46\xda\xf4\xc0\xbf\x86\x99\xfe"
    "\xb8\xa0\x6b\x64\x55\xf7\xc8\x20\x49\x6a\x29\x19\xfe\xc9\xa8\xff"
    "\x48\x01\xc4\x88\xb4\xd2\x27\x88\xd6\xad\x7f\x7a\xa9\x16\xaf\x49"
    "\x9f\x39\xc4\xd5\x5a\x0b\xaa\xb7\xe8\x8b\xfe\x74\x42\x9e\xf6\x35"
    "\x15\xf3\x71\xc4\x12\xba\xd2\x6a\x61\xce\x51\x54\xba\x6c\x95\x3f"
    "\x94\xff\x36\xcd\x96\x02\xf5\x9c\x87\x43\x73\x5b\x95\x1c\xbe\x90"
    "\x6a\x19\x97\x41\xf2\x20\xb4\x5d\x67\x7c\x68\xdd\x84\x08\x64\x5d"
    "\xc0\xcf\x23\xcd\xdb\x69\x81\x9e\xf7\xde\xc4\x37\x3d\x6f\x0e\x2a"
    "\xf3\x02\x03\x01\x00\x01"
    ;
#elif defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC)
  static const unsigned char unlock_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xb6\xb0\xb7\x5a\x8e\x6d\xe4\xfe\xe6\xb3\x88\x3a\x58\xab\x49"
    "\xf0\xca\x41\xfb\x5e\xa8\x74\x93\xc9\x3c\x18\x03\xab\x04\x1a\x3c"
    "\xa7\xc7\xbd\x4f\x8d\x97\xe2\x00\xbb\xd9\xbe\x8e\xc7\xe7\x6b\x14"
    "\x65\xca\xa0\xb8\x70\xb9\x18\x7a\x73\x64\x1d\x87\x06\xff\x01\xca"
    "\xc3\x8c\x67\x1a\x8b\xe2\x94\xf3\x3a\x44\x01\xa6\x98\xb6\x4e\x6c"
    "\x07\xc3\xf2\xd5\x49\xb8\x55\x04\x2a\x7c\x20\x25\x5a\x4f\x56\x13"
    "\xc6\xf6\x58\x1c\x4b\xcb\x3d\x34\x09\xfe\xa6\x49\xac\x7f\x2e\x19"
    "\x39\xb5\x8c\xae\xe9\xf3\xe9\x22\x1a\xb6\x03\xeb\xfc\x14\xb8\x1e"
    "\x11\x19\xe2\x94\xa4\x66\x73\x17\x0b\x2c\x54\xde\x7c\xad\xa4\x9b"
    "\xf6\x52\x7c\xcd\xfd\x82\x67\xec\x70\x1a\x54\x97\x4e\x1e\x90\x17"
    "\xb9\xb5\x58\x44\xb2\x21\xcd\x5d\x3b\x19\x60\xdb\x3d\x01\xa9\x6f"
    "\x66\xf2\xd2\x81\x89\x29\xd7\x51\xc2\x39\x86\x52\x64\x18\x3b\x89"
    "\x70\x65\x6e\x45\x68\x42\xd8\xfc\x7a\x54\x79\xd2\x5b\xdc\xfb\xaf"
    "\x68\x6c\x54\x48\xbc\x0b\x8e\x5f\xfb\xfe\xa5\x62\xb0\x3f\x39\x1c"
    "\x99\xb7\x73\x07\x4b\x3d\x74\x3b\xc8\x40\xcf\xe5\xe1\x2d\x94\x1c"
    "\xae\x6b\xe7\x31\x6f\x45\x7d\xcd\x51\x73\xfb\x01\xd8\x7c\xf2\xb9"
    "\xfb\x02\x03\x01\x00\x01"
    ;
#else
  static const unsigned char unlock_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xba\xf9\x4e\x8f\xdd\x10\xad\xd3\xfd\xc0\x53\x5c\x07\x1e\xa1"
    "\xd0\xe3\xd5\xfc\x9a\x53\xd8\x7b\xce\x31\x62\xaf\xb5\xfd\x3b\xe2"
    "\xe0\xe9\x14\x6f\x56\x42\x2b\x64\xa8\x90\xed\xa0\xd3\x0c\x70\xfa"
    "\x97\x80\x16\x5d\xaf\x15\x50\x18\x8a\x4d\x44\x6c\x59\x36\x26\xd8"
    "\x6e\x32\x68\x9a\x33\x6f\xf9\x80\xfd\x90\xae\xb2\xf6\xa5\xab\x59"
    "\x1a\xa4\x7e\x34\x1f\xa2\xf7\x86\x42\x10\xe4\xf1\x78\x17\xdf\x2f"
    "\xf0\x71\x36\xe6\xd2\xad\x06\xb4\x2b\xaa\x34\x41\x1d\x83\x37\x74"
    "\x42\x13\xa6\xcd\x38\xd3\x65\xcf\x68\x56\xa9\xf5\x35\xdf\x99\xbe"
    "\xf8\x50\xfc\x6c\xeb\x95\x10\xc8\x0f\x9c\x55\x4a\x99\xee\xf9\x5b"
    "\x59\x3c\x63\x29\x15\x10\xf6\xe3\x31\xe2\x7c\x14\x90\xac\xc3\xc6"
    "\xf1\x75\xd0\xdd\xde\x6c\x2e\x34\x2b\xae\xcf\x9d\x45\x0d\xd8\xea"
    "\xa0\x63\x04\x7a\x0c\x5b\x80\x5c\xcd\xb1\xc9\x69\xbd\x06\x85\xe6"
    "\x5c\xdd\x2b\x19\xf8\xcc\xc3\x73\x72\xce\xde\x4b\xaf\x56\x66\x56"
    "\x06\x70\x91\x44\xb9\x10\x54\xcd\x98\x5a\x19\x9e\x6f\xbb\x68\x47"
    "\x9c\xc0\x4c\xc5\x82\x7d\xe9\xe8\x91\x69\xff\x61\xfc\xe0\x71\xb4"
    "\xdb\xdb\x8d\xe0\x20\x06\x2c\xd6\x82\x6f\xd7\x33\xdd\x0b\xd9\x4a"
    "\xe9\x02\x03\x01\x00\x01"
    ;
#endif

  const int unlock_key_size = sizeof(unlock_key);

  if (!key_len)
    return NULL;

#if defined(CONFIG_MTK_BD_MT164B_10AT_M7632_ANNA)
  static const unsigned char unlock_1p_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xca\xb8\xf7\xe1\xd5\x58\x04\x7e\xd4\xda\x8e\x54\x99\x64\x38"
    "\xf8\x26\xba\x7c\xbf\x72\x2a\xcc\x2b\xfd\xae\x76\x3d\xb9\x98\xf5"
    "\x8e\xeb\x4c\x39\xe6\x99\xd7\x89\x5d\x43\x63\xf8\x18\xed\xc2\xc1"
    "\xea\xcf\x68\xca\xf7\xf2\xe4\x92\x10\x5b\xcb\x88\xcf\xd5\x07\xdf"
    "\xd8\xda\x7d\x23\x01\x76\xbc\x39\x42\xed\x4a\xee\xd1\xf2\x03\x94"
    "\x7b\xc9\xa3\xa8\x76\xf3\x86\x76\x7b\xad\x66\x34\xc9\xc4\x35\xb3"
    "\x9f\xdf\x32\xf7\x83\x75\xaa\xdc\xd1\xec\xa2\xe3\x5a\x3c\xec\xce"
    "\xbc\x7b\xa7\xfa\xde\x21\x0a\x90\x5f\xb0\x51\x2d\x2e\x64\x42\x12"
    "\x8d\x23\x94\x96\xee\x60\x34\x07\x9b\x62\x2c\x78\xca\xad\x4f\xf3"
    "\x8c\xb1\xa2\x65\xf7\xd9\x48\x0b\x2c\x9f\x02\x1a\x58\x8a\x0f\x26"
    "\xf9\x20\x35\x7c\x24\xd5\x2e\x7b\x5f\x55\xdc\x67\xc7\xa1\x89\x86"
    "\x0e\xc9\xc3\xc7\xa3\x05\xc8\x7d\xf8\xcc\x9b\x6e\x99\x1a\x81\x57"
    "\x80\xb2\xe2\x37\x54\x5d\xd1\xe0\x5f\xa8\x99\x5a\x0e\x96\x7c\xfe"
    "\xf9\xfe\xed\xbd\x65\x21\xe5\x6e\xac\xb7\x4b\x43\xcc\xb3\xa7\x51"
    "\xc0\xae\x2a\xf1\x82\x5e\xc6\x34\xab\xe8\xd5\x9a\xf9\x2e\x61\xb2"
    "\x7f\x7d\x55\xda\xe3\x9b\x49\x7b\x34\xef\xc5\x89\x92\xf1\x02\x69"
    "\x37\x02\x03\x01\x00\x01"
    ;

  const int unlock_1p_key_size = sizeof(unlock_1p_key);

  #define PROP_SIZE 32
  char prop_ammo[PROP_SIZE+1] = {0,};

  idme_get_oem_data_field("ammo_var=", prop_ammo, PROP_SIZE);

  if(!strcmp(prop_ammo, "anna-kt")){
    *key_len = unlock_1p_key_size;
    return unlock_1p_key;
  }
#endif

  *key_len = unlock_key_size;
  return unlock_key;
}

#if defined(CONFIG_MTK_BD_MT164B_10AT_M7632_ANNA)
const unsigned char *amzn_get_sign_key(unsigned int *key_len)
{
  static const unsigned char sign_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xba\xf9\x4e\x8f\xdd\x10\xad\xd3\xfd\xc0\x53\x5c\x07\x1e\xa1"
    "\xd0\xe3\xd5\xfc\x9a\x53\xd8\x7b\xce\x31\x62\xaf\xb5\xfd\x3b\xe2"
    "\xe0\xe9\x14\x6f\x56\x42\x2b\x64\xa8\x90\xed\xa0\xd3\x0c\x70\xfa"
    "\x97\x80\x16\x5d\xaf\x15\x50\x18\x8a\x4d\x44\x6c\x59\x36\x26\xd8"
    "\x6e\x32\x68\x9a\x33\x6f\xf9\x80\xfd\x90\xae\xb2\xf6\xa5\xab\x59"
    "\x1a\xa4\x7e\x34\x1f\xa2\xf7\x86\x42\x10\xe4\xf1\x78\x17\xdf\x2f"
    "\xf0\x71\x36\xe6\xd2\xad\x06\xb4\x2b\xaa\x34\x41\x1d\x83\x37\x74"
    "\x42\x13\xa6\xcd\x38\xd3\x65\xcf\x68\x56\xa9\xf5\x35\xdf\x99\xbe"
    "\xf8\x50\xfc\x6c\xeb\x95\x10\xc8\x0f\x9c\x55\x4a\x99\xee\xf9\x5b"
    "\x59\x3c\x63\x29\x15\x10\xf6\xe3\x31\xe2\x7c\x14\x90\xac\xc3\xc6"
    "\xf1\x75\xd0\xdd\xde\x6c\x2e\x34\x2b\xae\xcf\x9d\x45\x0d\xd8\xea"
    "\xa0\x63\x04\x7a\x0c\x5b\x80\x5c\xcd\xb1\xc9\x69\xbd\x06\x85\xe6"
    "\x5c\xdd\x2b\x19\xf8\xcc\xc3\x73\x72\xce\xde\x4b\xaf\x56\x66\x56"
    "\x06\x70\x91\x44\xb9\x10\x54\xcd\x98\x5a\x19\x9e\x6f\xbb\x68\x47"
    "\x9c\xc0\x4c\xc5\x82\x7d\xe9\xe8\x91\x69\xff\x61\xfc\xe0\x71\xb4"
    "\xdb\xdb\x8d\xe0\x20\x06\x2c\xd6\x82\x6f\xd7\x33\xdd\x0b\xd9\x4a"
    "\xe9\x02\x03\x01\x00\x01"
    ;

    const int sign_key_size = sizeof(sign_key);

    if (!key_len)
      return NULL;

    *key_len = sign_key_size;
    return sign_key;
}
#endif

#if defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332) || defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC) || defined(CONFIG_MTK_BD_MT168B_10AT_19133_MT5870_M7332_ABC)
const unsigned char *amzn_get_boot_key(unsigned int *key_len)
{
  static const unsigned char boot_key[] =
    "\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
    "\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
    "\x00\xb5\xdc\xea\x30\x24\xb3\xda\xf2\x04\x3d\xef\x69\x09\x37\xf9"
    "\x09\x6d\xaa\x51\x81\x2e\x15\x13\x4e\xed\x32\x99\x0f\xbd\x62\xbf"
    "\x9b\x79\xbe\x67\xbc\x9b\x49\x6b\xc0\xaf\x61\xed\xf4\x38\xf5\x1f"
    "\x0f\x9a\xe5\xe1\x1f\xc7\x93\x42\x02\x03\x57\xf5\xa2\x86\x68\x96"
    "\x31\x31\x18\xaf\xd2\x2c\xa5\x4d\x8c\xab\x0b\x5e\xcd\xe4\xef\x46"
    "\xb2\xb2\xc3\x7f\xdd\x60\x6b\x30\xc5\xa5\xe1\x5f\xc9\x5b\x61\x8a"
    "\x74\xac\xd9\xaa\x3f\x82\xec\x1f\x06\x89\xa2\x77\x50\xab\xbb\xab"
    "\x36\xdb\x17\xec\x3d\x55\x88\x2d\xbc\x6d\xea\xa2\x3c\x5c\xa3\x29"
    "\x60\x8b\x34\x18\xdb\x28\x1d\x94\xc0\x3d\xd9\x17\x16\x82\xa0\xe3"
    "\x0c\x3c\x78\x54\x41\xbd\xe0\xd0\x88\x21\x36\x35\x0e\xa9\x60\xda"
    "\xb5\x93\xdf\xe6\xca\x8e\x11\x1e\x8d\x2e\x74\xb3\x37\x71\x4e\x48"
    "\xef\x44\xcf\xb7\x80\x9b\x6e\x10\xcc\x78\x43\x38\x6c\xdf\xd4\xbe"
    "\x7c\x56\xe6\x06\x3b\x46\x30\xac\x25\x57\x49\x5a\x0d\xae\x85\xea"
    "\x05\x98\x62\xd1\x32\x85\x21\x98\xe8\x88\x73\x2f\xc4\xa1\x53\xc9"
    "\xe2\x21\x24\xab\xad\xfb\x2f\x4d\x20\xdb\xd5\xfd\x4a\xdd\xd8\x29"
    "\xdf\x58\x2e\xe8\xb6\x99\xeb\x7f\x41\xa8\x18\x5e\x8f\x4f\x18\xf0"
    "\x1b\x02\x03\x01\x00\x01"
     ;

  const int boot_key_size = sizeof(boot_key) - 1;

  if (!key_len)
    return NULL;

  *key_len = boot_key_size;
  return boot_key;
}
#endif

int amzn_device_is_unlocked(void)
{
#if defined(UFBL_FEATURE_UNLOCK)
  unsigned char signed_code[SIGNED_UNLOCK_CODE_LEN] = { 0 };

  if ( !idme_get_var_external("unlock_code", signed_code, sizeof(signed_code)) &&
       !amzn_verify_unlock((void*)signed_code, sizeof(signed_code)) ) {
    return 1;
  }
#endif
#if defined(UFBL_FEATURE_ONETIME_UNLOCK)
  if ( amzn_target_is_onetime_unlocked() ) {
    return 1;
  }
#endif
  return 0;
}

#if defined(UFBL_FEATURE_ONETIME_UNLOCK)
int amzn_get_one_tu_code(unsigned char *code, unsigned int *len)
{
  static unsigned char code_generated = 0;
  static unsigned char one_tu_code[ONETIME_UNLOCK_CODE_LEN + 1] = {0};

  if (!code || !len || *len < ONETIME_UNLOCK_CODE_LEN)
    return -1;

  if (!code_generated) {
/**
 * Different SoC/Product may have different scheme to add entropy into PRNG.
 * For sophia, take get_timer (8 bytes) and unlock code as entropy
 */
#define ENTROPY_LEN (UNLOCK_CODE_LEN + 8)
    static unsigned char entropy[ENTROPY_LEN] = {0};
    unsigned int unlock_code_len = UNLOCK_CODE_LEN;

    sprintf(entropy, "%08x", get_timer(0));
    if (amzn_get_unlock_code(&entropy[strlen(entropy)], &unlock_code_len)) {
      return -1;
    }
/**
 * amzn_get_onetime_random_number will return a binary string which is not readable.
 * The binary string cannot be returned via fastboot so using base64 encode it.
 */
// compute how many random bytes do we need so that the converted size is the target length
#define RANDOM_BYTES_SIZE (ONETIME_UNLOCK_CODE_LEN + 3) / 4 * 3
    uint8_t random_bytes[RANDOM_BYTES_SIZE] = {0};
    unsigned int out_len = sizeof(one_tu_code);

    if (amzn_get_onetime_random_number(entropy, strlen(entropy),
                                       random_bytes, sizeof(random_bytes)))
      return -1;

    if (amzn_onetime_unlock_b64_encode(random_bytes, sizeof(random_bytes),
                                       one_tu_code, &out_len)) {
      return -1;
    }
    code_generated = 1;
  }
  memcpy(code, one_tu_code, ONETIME_UNLOCK_CODE_LEN);
  *len = ONETIME_UNLOCK_CODE_LEN;
  return 0;
}


int amzn_get_onetime_unlock_root_pubkey(const unsigned char **key, unsigned int *key_len)
{
  static const unsigned char onetime_unlock_key[] = ONETIME_UNLOCK_KEY;
  const int onetime_unlock_key_size = sizeof(onetime_unlock_key);

  if (!key || !key_len)
    return -1;

#if defined(CONFIG_MTK_BD_MT164B_10AT_M7632_ANNA)
  static const unsigned char onetime_1p_unlock_key[] = ONETIME_1P_UNLOCK_KEY;
  const int onetime_1p_unlock_key_size = sizeof(onetime_1p_unlock_key);

  #define PROP_SIZE 32
  char prop_ammo[PROP_SIZE+1] = {0,};

  idme_get_oem_data_field("ammo_var=", prop_ammo, PROP_SIZE);

  if(!strcmp(prop_ammo, "anna-kt")){
    *key_len = onetime_1p_unlock_key_size;
    *key = onetime_1p_unlock_key;
    return 0;
  }
#endif

  *key_len = onetime_unlock_key_size;
  *key = onetime_unlock_key;
  return 0;
}
#endif

#if defined(UFBL_FEATURE_SECURE_FLASHING)
const unsigned char *amzn_get_sec_flashing_root_pubkey(unsigned int *key_len)
{
	static const unsigned char root_pubkey[] =
	"\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01"
	"\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01"
	"\x00\xb4\xd2\x63\x33\x58\xff\x8d\xaf\x32\x3f\xe2\x16\xa2\x9c\x33"
	"\xcc\xd1\x01\x3c\x09\x96\xe6\xa2\x47\xa9\x20\xd3\xd2\xbc\x89\xbc"
	"\xef\x9d\x26\xf7\xa3\x49\x35\x64\x72\x21\x42\xf7\x14\x73\xf8\x64"
	"\x4d\xd4\xa8\x46\x4b\xe0\x13\x48\xa9\xe7\x50\xa8\x14\xf1\xc3\x46"
	"\x7a\xfe\xf4\x8d\x1d\xd2\xa2\x65\x81\xd5\x42\x90\xcd\x16\x11\x97"
	"\x48\xf3\x61\xbd\xb2\xd3\x66\xb1\xa4\x50\x80\x52\x70\xcf\x84\x71"
	"\x9e\x54\x12\x6d\x51\x18\x53\x34\xc7\xfa\x2c\x4d\x54\x67\xce\xa2"
	"\xf2\xa4\x43\x86\xdf\xe6\x3f\xfd\x29\xbc\x51\x56\x8e\xcf\xdb\xf0"
	"\x6d\x70\x57\x1d\xbb\x71\x5c\xd7\xcd\xb2\x23\xcf\xb1\xb2\x4f\x94"
	"\x99\xbc\x52\xa6\xd1\x82\x6a\x89\x76\xd7\x89\x50\xba\xcd\x84\x0e"
	"\x47\xec\x21\x2c\x3e\x95\x20\xab\xf0\x0c\x7e\xf7\x02\xe1\x06\xdf"
	"\x87\x74\x44\xc9\xb7\x42\x82\x9e\x8d\x94\xae\x7d\x04\xf7\x29\x72"
	"\x78\xe2\x34\xba\x78\xa5\x4b\x2c\xb3\x37\x51\xba\x4b\xd8\xa3\x07"
	"\xa1\x05\x26\xf3\x94\x5c\xb6\xe1\xc8\x33\x1e\x1d\x29\x88\x65\xd8"
	"\xf5\xac\x39\x50\x3a\xe6\x13\x7d\x6a\xb0\x01\xf8\x7c\x4c\x8e\xa6"
	"\x9c\xd5\xec\xed\x39\x12\xbc\xc4\x38\x26\x9f\x92\x61\xa2\xad\x52"
	"\x61\x02\x03\x01\x00\x01"
	;

	if (!key_len)
	  return NULL;
	*key_len = sizeof(root_pubkey);
	return root_pubkey;
}

int amzn_verify_device_meta(const unsigned char *data, unsigned int len)
{
	int i;
	const unsigned int max_hwid_num = 16;

	typedef struct type_device_meta {
		int hardware_id[max_hwid_num];
		unsigned int reserved[16];
	} device_meta;

	device_meta *meta = (device_meta *)data;

	if (!data || len != DEVICE_META_SIZE) {
		return -1;
	}

	for (i = 0; i < max_hwid_num; i++) {
		if (meta->hardware_id[i] == amzn_get_hardware_id()) {
			return 0;
		}
	}
	return -2;
}

const unsigned char * amzn_get_sec_flashing_pk_blacklist(unsigned int *len)
{
	static const unsigned char pk_blacklist[][SHA256_DIGEST_SIZE] = {
	};
	if (!len)
		return NULL;
	*len = sizeof(pk_blacklist) / sizeof(pk_blacklist[0]);
	return (const unsigned char *)pk_blacklist;
}

static unsigned int get_random_number(void)
{
    int rand = 0;
    int seed = 0;
    seed = rRand((unsigned int)get_timer(0),0);
    rand = rRand((unsigned int)get_timer(0), (unsigned int)seed);
    return rand;
}

int amzn_get_sec_flashing_code(unsigned char *code, unsigned int *len)
{
  static unsigned char sec_flashing_code[UNLOCK_CODE_LEN + 1] = {0};
  static unsigned char code_generated = 0;
  unsigned int unlock_code_len = UNLOCK_CODE_LEN;
  unsigned int rand1, rand2;

  if (!code || !len || *len < UNLOCK_CODE_LEN)
    return -1;

  if (!code_generated) {
	if(amzn_get_unlock_code(sec_flashing_code, &unlock_code_len)){
		return -1;
	}
	rand1 = get_random_number();
	rand2 = get_random_number();
	sprintf(&sec_flashing_code[16], "%08x%08x", rand1, rand2);
	code_generated = 1;
  }
  memcpy(code, sec_flashing_code, UNLOCK_CODE_LEN);
  *len = UNLOCK_CODE_LEN;
  return 0;
}
#endif

